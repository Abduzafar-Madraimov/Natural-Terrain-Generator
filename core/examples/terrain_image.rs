use image::{GrayImage, Luma};
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 16×16 sample data from noise_demo2d:
    let data: Vec<Vec<f32>> = vec![
        vec![
            -0.426, -0.476, 0.147, 1.020, 0.287, 0.130, 0.796, -0.204, -0.546, -0.338, -0.913,
            -0.020, -0.249, 0.051, 0.591, 0.257,
        ],
        vec![
            0.000, -0.838, -0.580, 0.420, 1.287, 1.130, 1.147, 0.147, -0.396, -1.067, -0.411,
            -0.486, -0.357, 0.643, 0.746, -0.029,
        ],
        vec![
            0.000, 0.000, -0.393, -0.404, 0.376, 0.979, 0.366, 0.137, 0.329, -0.198, -0.159, 0.514,
            0.319, 1.318, 1.240, 0.300,
        ],
        vec![
            0.000, -0.843, 0.000, 0.106, 0.208, -0.021, -0.434, 0.030, 0.687, 0.802, 0.521, 0.138,
            0.647, 0.318, 0.240, 0.307,
        ],
        vec![
            0.000, -0.068, 0.000, -0.103, -0.792, -0.650, -0.789, -0.850, -0.014, 0.469, 0.776,
            0.386, 0.733, 0.138, 0.580, 0.122,
        ],
        vec![
            -0.068, -0.932, -0.103, -0.794, -0.103, 0.350, -0.070, -0.040, -0.009, -0.237, -0.131,
            -0.200, -0.178, 0.723, 1.004, 0.791,
        ],
        vec![
            0.000, -0.068, -1.045, -0.103, 0.000, 0.000, -0.606, 0.124, 0.287, 0.714, 0.074,
            -0.363, 0.511, -0.275, 0.296, -0.000,
        ],
        vec![
            0.000, -0.519, -0.045, 0.559, 0.000, -0.574, 0.000, -0.401, 0.039, -0.065, 0.359,
            0.298, -0.413, 0.587, -0.140, 0.785,
        ],
        vec![
            0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, -0.017, -0.518, -0.641, -0.702,
            -0.195, -0.320, 0.114, 0.952,
        ],
        vec![
            0.000, -0.399, 0.000, -0.939, 0.000, -0.448, 0.000, 0.570, 0.000, 0.078, -0.664,
            -0.235, -0.777, -0.425, 0.575, 0.376,
        ],
        vec![
            0.000, 0.000, -0.344, 0.000, 0.000, 0.000, 0.501, 0.000, 0.000, 0.000, 0.336, 0.661,
            0.223, -0.674, 0.094, 1.094,
        ],
        vec![
            0.000, 0.020, 0.000, -0.264, 0.000, 0.878, 0.000, -0.154, 0.000, 0.787, 0.000, -0.031,
            0.746, 0.173, 0.133, 1.112,
        ],
        vec![
            0.000, 0.000, 0.000, 0.000, -0.085, 0.008, 0.000, 0.000, 0.000, 0.000, 0.000, 0.004,
            0.938, 0.336, 1.133, 1.256,
        ],
        vec![
            0.000, 0.377, 0.000, 0.918, 0.016, 1.008, 0.064, 0.094, 0.000, -0.313, 0.008, 1.004,
            0.032, 0.971, 0.757, 0.379,
        ],
        vec![
            0.000, 0.000, -0.142, 0.000, 0.000, 0.032, 0.723, 0.000, 0.000, 0.000, 0.626, 0.016,
            0.000, 0.000, -0.058, -0.107,
        ],
        vec![
            0.000, 0.678, 0.000, -0.244, 0.000, -0.590, 0.000, 0.391, 0.000, -0.290, 0.002, 1.002,
            0.008, 0.939, 0.000, 0.893,
        ],
    ];

    // Find min/max to normalize:
    let mut min = f32::INFINITY;
    let mut max = f32::NEG_INFINITY;
    for row in &data {
        for &v in row {
            min = min.min(v);
            max = max.max(v);
        }
    }

    // Create a 16×16 grayscale image buffer:
    let mut img = GrayImage::new(16, 16);

    for (y, row) in data.iter().enumerate() {
        for (x, &v) in row.iter().enumerate() {
            // Normalize v into [0.0, 1.0]:
            let norm = if (max - min).abs() < std::f32::EPSILON {
                0.5
            } else {
                (v - min) / (max - min)
            };
            // Map to 0..=255
            let gray = (norm * 255.0).round() as u8;
            img.put_pixel(x as u32, y as u32, Luma([gray]));
        }
    }

    // Save to disk:
    let out_path = Path::new("terrain16x16.png");
    img.save(out_path)?;
    println!("Saved grayscale terrain to {:?}", out_path);

    Ok(())
}
